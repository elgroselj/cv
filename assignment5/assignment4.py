# -*- coding: utf-8 -*-
"""assignment4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ttq8Y63J7Z7JO5rkAcf2cB1zwfh5AxMY
"""

import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import cv2
import os


def gaussian(o=2):
  N = int(np.ceil(3*o))
  k = np.zeros(2*N+1)
  inter = np.arange(-N,N+1)
  return 1/(np.sqrt(2*np.pi)*o) * np.exp(-1*(np.square(inter)/(2*o*o)))

def gaussdx(o=2):
  N = int(np.ceil(3*o))
  k = np.zeros(2*N+1)
  inter = np.arange(-N,N+1)
  not_normal = -1/(np.sqrt(2*np.pi)*o*o*o)*inter * np.exp(-1*(np.square(inter)/(2*o*o)))
  #not_normal = -1* not_normal # flip kernel as it is not symmetric
  return not_normal/np.sum(np.abs(not_normal))

def filter(I, kernel2D):
  I_k = cv2.filter2D(src=I, ddepth=-1, kernel = kernel2D)
  return I_k

def get_G_D(o):
  G = -1*gaussian(o)
  G = G.reshape(1,len(G))
  D = gaussdx(o)
  D = D.reshape(1,len(D))
  return (G,D)

def part_deriv_x(I,o):
  G,D = get_G_D(o)
  return filter(filter(I, G.T),D) # x

def part_deriv_y(I,o):
  G,D = get_G_D(o)
  return filter(filter(I, G),D.T) # y

def part_deriv_x_x(I,o):
  G,D = get_G_D(o)
  return part_deriv_x(part_deriv_x(I,o),o) # x x

def part_deriv_y_y(I,o):
  G,D = get_G_D(o)
  return part_deriv_y(part_deriv_y(I,o),o) # y y

def part_deriv_x_y(I,o):
  G,D = get_G_D(o)
  return part_deriv_x(part_deriv_y(I,o),o) # x y

###########################################33
def gradient_magnitude(I,o): # I = gray
  Ix = part_deriv_x(I,o)
  Iy = part_deriv_y(I,o)
  M = np.sqrt(np.multiply(Ix,Ix)+np.multiply(Iy,Iy))
  A = np.arctan2(Iy,Ix)
  return (M,A)

"""EX 1a ne najdem test_points.jpg tresh je zlo mejhen??

Bigger sigma bigger dots are detected.
"""

def loc_max_box(A,y,x,box_size=1):#9,25
  if box_size == 1:
    return (A[y,x] >= max(A[y+1,x-1],A[y+1,x+1],A[y+1,x],A[y,x+1]) and A[y,x] > max(A[y,x-1],A[y-1,x-1],A[y-1,x],A[y-1,x+1]))
  elif box_size == 2:
    return (A[y,x] > max(A[y-2,x-2], A[y-2,x-1], A[y-2,x], A[y-2,x+1], A[y-2,x+2],
                         A[y-1,x-2], A[y-1,x-1], A[y-1,x], A[y-1,x+1], A[y-1,x+2],
                         A[y,x-2],   A[y,x-1]) and
            A[y,x] >= max(A[y,x+1], A[y,x+2],
                          A[y+1,x-2], A[y+1,x-1], A[y+1,x], A[y+1,x+1], A[y+1,x+2],
                          A[y+2,x-2], A[y+2,x-1], A[y+2,x], A[y+2,x+1], A[y+2,x+2]))


def nonmaxima_suppression_box(A,box_size=2):
  A_ = np.copy(A)
  for x in range(box_size,len(A[0])-box_size):
    for y in range(box_size,len(A)-box_size):
      if not loc_max_box(A_,y,x,box_size):
        A_[y,x] = 0
  return(A_)

def points_nonmax_tresh(hp,tresh=0.5,box_size=2):
  I = nonmaxima_suppression_box(hp,box_size)
  I = np.where(I>tresh,1,0)
  return(I)

def get_points(hpnt):
  X = []
  Y = []
  for y in range(len(hpnt)):
    for x in range(len(hpnt[0])):
      if hpnt[y,x] > 0:
        X.append(x)
        Y.append(y)
  X = np.array(X)
  Y = np.array(Y)
  return (X,Y)

def hessian_points(I,o):
  Ixx = part_deriv_x_x(I,o)
  Iyy = part_deriv_y_y(I,o)
  Ixy = part_deriv_x_y(I,o)

  R = np.multiply(Ixx,Iyy) - np.multiply(Ixy,Ixy)
  R = R-np.amin(R)
  R = R/np.amax(R)
  return(R)
        



#I = imread_gray('/content/drive/MyDrive/ColabNotebooks/assignment4/images/test_points.jpg')

"""EX 1b"""

def harris_points(I,o):
  Ix = part_deriv_x(I,o)
  Iy = part_deriv_y(I,o)

  o2 = 1.6*o
  G,_ = get_G_D(o2)

  a = filter(Ix*Ix,G)
  d = filter(Iy*Iy,G)

  det = np.multiply(a,d)
  trace = a+d

  alfa = 0.06
  R = det - alfa * np.multiply(trace,trace)
  R = R-np.amin(R)
  R = R/np.amax(R)
  return(R)

def hell_dist(v1,v2):
  return np.sqrt(1/2 * np.sum(np.square(np.sqrt(v1)-np.sqrt(v2))))

def find_correspondences(descA,descB):
  corr = np.zeros((len(descA),len(descB)))
  for i in range(len(descA)):
    for j in range(len(descB)):
      corr[i,j] = hell_dist(descA[i],descB[j])

  a = np.arange(len(descA))
  b = np.argmin(corr, axis=1)
  ab = np.column_stack((a,b))
  #print(ab)
  return(ab)


def find_matches(Ia,Ib):
  X1,Y1 = get_points(points_nonmax_tresh(hessian_points(Ia,o)))
  descA = simple_descriptors(Ia,Y1,X1)

  X2,Y2 = get_points(points_nonmax_tresh(hessian_points(Ib,o)))
  descB = simple_descriptors(Ib,Y2,X2)

  ab = find_correspondences(descA,descB)
  #print(ab)
  ba = find_correspondences(descB,descA)
  #print(ba)
  ab_ = ba[:,np.array([1,0])]
  r = []
  for i in range(len(ab)):
    for j in range(len(ab_)):
      if ab[i,0] == ab_[j,0] and ab[i,1] == ab_[j,1]:
        r.append(ab[i,:])
        break
  
  matches = np.array(r)
  xy1 = np.column_stack((X1,Y1))[matches[:,0]]
  xy2 = np.column_stack((X2,Y2))[matches[:,1]]
  display_matches(Ia,xy1,Ib,xy2)
  points = np.column_stack((xy1,xy2))
  return points



def g(x,l):
  N = int(l/2)
  o = N/3
  g = 1/(np.sqrt(2*np.pi)*o) * np.exp(-1*(np.square(x)/(2*o*o)))
  return g


def sift_hist(I,o,dangle,n_angle_bins=8,pcs=4):
  M, A = gradient_magnitude(I,o)

  v_unit = int(I.shape[0]//pcs)
  h_unit = int(I.shape[1]//pcs)
  

  H_ = []
  for v in range(pcs):
    for h in range(pcs):
      H = np.zeros(n_angle_bins)
      for y in range(v_unit):
        for x in range(h_unit):
          y_ = v*pcs+y
          x_ = h*pcs+x
          #print(y_,x_)
          a_bin = int(np.floor((A[y_,x_]+dangle)%(2*np.pi/n_angle_bins))) #(4),3 ... 1,0,-1 .. -4
          a_bin = 3 if a_bin == 4 else a_bin
          a_bin += 4 #0,...7
          H[a_bin] += M[y_,x_] * g(x,h_unit) * g(y,v_unit)
      #print(H)
      H_ = np.concatenate([H_,H])
  H_ = H_/np.amax(H_)
  return(H_)



def sift(I,x,y,d,o=5):
  region = I[y-d:y+d+1,x-d:x+d+1]
  g = gaussian(d)
  n_angle_bins=36
  grad_h = sift_hist(region,o,dangle=0,n_angle_bins=n_angle_bins,pcs=1)
  ix_maxgrad = np.where(grad_h > 0.8)
  for a_bin in ix_maxgrad:
    dangle = (a_bin-4)*(2*np.pi/n_angle_bins)
    hist = sift_hist(region,o,dangle,n_angle_bins)
    return(hist)

def sift_v(I,Y,X,d=10):
  hists = []
  for i in range(len(X)):
    #print(X[i],Y[i])
    hists.append(sift(I,X[i],Y[i],d))
  return(np.array(hists))


def discard_edge_pixels(I,X,Y,d):
  mask = (d<X) & (X+d+1<(len(I[0]))) & (d<Y) & (Y+d+1<(len(I)))
  X_ = X[mask]
  Y_ = Y[mask]

  return((X_,Y_))


def find_matches_sift(Ia,Ib,d=10):
  X1,Y1 = get_points(points_nonmax_tresh(hessian_points(Ia,o)))
  X1,Y1 = discard_edge_pixels(Ia,X1,Y1,d)
  descA = sift_v(Ia,Y1,X1,d)

  X2,Y2 = get_points(points_nonmax_tresh(hessian_points(Ib,o)))
  X2,Y2 = discard_edge_pixels(Ia,X2,Y2,d)
  descB = sift_v(Ib,Y2,X2,d)

  ab = find_correspondences(descA,descB)
  #print(ab)
  ba = find_correspondences(descB,descA)
  #print(ba)
  ab_ = ba[:,np.array([1,0])]
  r = []
  for i in range(len(ab)):
    for j in range(len(ab_)):
      if ab[i,0] == ab_[j,0] and ab[i,1] == ab_[j,1]:
        r.append(ab[i,:])
        break
  
  matches = np.array(r)
  xy1 = np.column_stack((X1,Y1))[matches[:,0]]
  xy2 = np.column_stack((X2,Y2))[matches[:,1]]
  display_matches(Ia,xy1,Ib,xy2)
  points = np.column_stack((xy1,xy2))
  return points



def draw_keypoints(imagegray):
  features = cv2.SIFT_create()
  keypoints = features.detect(imagegray, None)
  
  output_image = cv2.drawKeypoints(imagegray, keypoints, 0, (0, 255, 0),
                                  flags=cv2.DRAW_MATCHES_FLAGS_DEFAULT)
  return(output_image)


"""EX 3a DELA"""

def estimate_homography(R,T):
  Xr = R[:,0]
  Yr = R[:,1]
  Xt = T[:,0]
  Yt = T[:,1]
  A = np.zeros((len(Xr)*2, 9))
  for i in range(len(Xr)):
    A[i*2,:] = np.array([Xr[i], Yr[i], 1, 0, 0, 0, -Xt[i]*Xr[i], -Xt[i]*Yr[i], -Xt[i]])
    A[i*2+1,:] = np.array([0, 0, 0, Xr[i], Yr[i], 1, -Yt[i]*Xr[i], -Yt[i]*Yr[i], -Yt[i]])
  _, _, VT = np.linalg.svd(A)
  h = VT[-1,:]
  h = h / VT[-1,-1]
  H = h.reshape((3,3))
  #print(H)
  return(H)


"""EX 3b DELA"""

import random
def estimate_homography(R,T):
  try:
    H = cv2.getPerspectiveTransform(np.float32(R),np.float32(T))
  except:
    return(None)
  return(H)

def inliers(R,T,H,area):
  ins = []
  for i in range(len(R)):
    x = np.array([[R[i,0],R[i,1],1]])
    x_ = H.dot(x.T)
    x_ = (x_/x_[-1])[:2]
    y = np.array([T[i,0],T[i,1]])
    err = np.sum(np.power(x_ - y,2))
    #print(err)
    if err <= area:
      ins.append(i)
  #errors = np.power(H*R-T,2) #..............
  #return(np.which(errors <= area))
  return(ins)

def ransac(R,T,n=1000,area=10000,enough_inliers=len(R)*0.8):
  insl_H = None
  for k in range(n):
    s = random.sample(range(len(R)),4)
    H = estimate_homography(R[s],T[s])
    if H is None: continue
    ins = inliers(R,T,H,area)
    if len(ins) >= enough_inliers:
      #print("*")
      H = estimate_homography(R[ins], T[ins])
      if H is None: continue
      ins = inliers(R,T,H,tresh)
    #else:
      #print("**")
    if insl_H is None or insl_H[0] < len(ins):
      insl_H = (len(ins),H)
  return insl_H[1]



from numpy.linalg import inv

def reform(Iold,H):
  # x_ = H*x
  # x = H-1 * x_
  I = np.zeros(Iold.shape)
  Hinv = inv(H)
  for x_ in range(len(I[0])):
    for y_ in range(len(I)):
      X_ = np.array([x_,y_,1])
      #x,y,1 = H-1 dot x_,y_,1
      X = Hinv.dot(X_)
      y = int(np.floor(X[1]/X[2]))
      x = int(np.floor(X[0]/X[2]))
      #print(y,x)
      if 0 <= x and x < len(Iold[0]) and 0 <= y and y < len(Iold):
        #print(y_,x_,y,x)
        I[y_,x_] = Iold[y,x]
  return(I)
